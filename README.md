

# dkimcrypt
`import "gitlab.one.com/go/dkimcrypt"`

* [Overview](#pkg-overview)
* [Index](#pkg-index)

## <a name="pkg-overview">Overview</a>
Package dkimcrypt provides convenient functions for en- or decrypting, as
well as signing and verifying data using a combination of local private key
files and public keys present in DKIM DNS TXT records




## <a name="pkg-index">Index</a>
* [Variables](#pkg-variables)
* [func Decrypt(selector, privkeypath string, in, key, mac []byte) (out []byte, err error)](#Decrypt)
* [func Encrypt(selector, domain string, in []byte) (out, key, mac []byte, err error)](#Encrypt)
* [func Sign(message []byte, privkeypath string) (out []byte, err error)](#Sign)
* [func Verify(message []byte, signature []byte, selector, domain string) (err error)](#Verify)


#### <a name="pkg-files">Package files</a>
[crypt_decrypt.go](/src/dkimcrypt/crypt_decrypt.go) [errors.go](/src/dkimcrypt/errors.go) [pubkey.go](/src/dkimcrypt/pubkey.go) [sign_verify.go](/src/dkimcrypt/sign_verify.go) 



## <a name="pkg-variables">Variables</a>
``` go
var (

    // ErrVerifyNoKeyForSignature no key
    ErrVerifyNoKeyForSignature = errors.New("no key for verify")

    // ErrVerifyKeyUnavailable when service (dns) is anavailable
    ErrVerifyKeyUnavailable = errors.New("key unavailable")

    // ErrVerifyTagVMustBeTheFirst if present the v tag must be the firts in the record
    ErrVerifyTagVMustBeTheFirst = errors.New("pub key syntax error: v tag must be the first")

    // ErrVerifyVersionMusBeDkim1 if pr√©sent flag v (version) must be DKIM1
    ErrVerifyVersionMusBeDkim1 = errors.New("flag v must be set to DKIM1")

    // ErrVerifyBadKeyType bad type for pub key (only rsa is accepted)
    ErrVerifyBadKeyType = errors.New("bad type for key type")

    // ErrVerifyRevokedKey key(s) for this selector is revoked (p is empty)
    ErrVerifyRevokedKey = errors.New("revoked key")

    // ErrVerifyBadKey when we can't parse pubkey
    ErrVerifyBadKey = errors.New("unable to parse pub key")

    // ErrVerifyNoKey when no key is found on DNS record
    ErrVerifyNoKey = errors.New("no public key found in DNS TXT")
)
```


## <a name="Decrypt">func</a> [Decrypt](/src/target/crypt_decrypt.go?s=2549:2636#L101)
``` go
func Decrypt(selector, privkeypath string, in, key, mac []byte) (out []byte, err error)
```
Decrypt will decrypt the data in 'in' and return it in 'out', given the path to a PEM-encoded
RSA private key file, an RSA-encrypted key, a message authentication code hash,
and a selector, which must be the same used for encryption



## <a name="Encrypt">func</a> [Encrypt](/src/target/crypt_decrypt.go?s=3366:3448#L130)
``` go
func Encrypt(selector, domain string, in []byte) (out, key, mac []byte, err error)
```
Encrypt will AES-encrypt the data given in 'in', and return the encrypted
version in 'out', as well as a key, which is RSA-encrypted using the public
key it finds in the DKIM-like TXT record at [selector]._domainkey.[domain],
and a message authentication code hash.  Use the same selector in 'Decrypt'



## <a name="Sign">func</a> [Sign](/src/target/sign_verify.go?s=236:305#L6)
``` go
func Sign(message []byte, privkeypath string) (out []byte, err error)
```
SIgn will sign the message in 'message' using the private key in the file at 'privkeypath'.



## <a name="Verify">func</a> [Verify](/src/target/sign_verify.go?s=1457:1539#L51)
``` go
func Verify(message []byte, signature []byte, selector, domain string) (err error)
```
Verify a signature given the signature, the message it signed and the
selector and domain that signed it. If err is nil, then the signature is
good.








- - -
Generated by [godoc2md](http://godoc.org/github.com/davecheney/godoc2md)
